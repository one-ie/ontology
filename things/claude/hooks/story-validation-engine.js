#!/usr/bin/env node

/**
 * Story Validation Engine - R.O.C.K.E.T. Framework Implementation
 * Implements 10-step validation process for story files
 */

import fs from 'fs';
import path from 'path';

// Configuration
const CONFIG = {
    CRITICAL_PENALTY: 3,
    SHOULD_FIX_PENALTY: 1.5,
    NICE_TO_HAVE_PENALTY: 0.5,
    COMPLETENESS_BONUS: 1,
    ANTI_HALLUCINATION_BONUS: 1,
    BASE_SCORE: 10
};

// Required story template sections
const REQUIRED_SECTIONS = [
    'Status',
    'Story', 
    'Acceptance Criteria',
    'Tasks / Subtasks',
    'Dev Notes',
    'Change Log',
    'Dev Agent Record'
];

class StoryValidationEngine {
    constructor(filePath, isSubAgent = false) {
        this.filePath = filePath;
        this.content = '';
        this.isSubAgent = isSubAgent;
        this.issues = {
            critical: [],
            shouldFix: [],
            niceToHave: []
        };
        this.score = CONFIG.BASE_SCORE;
        this.cache = new Map(); // Performance: Cache regex results
        this.sectionCache = new Map(); // Performance: Cache extracted sections
        this.subAgentInfo = null; // Store detected sub-agent information
    }

    async validate() {
        try {
            // Load and parse story file
            await this.loadStoryFile();
            
            // Execute 10-step validation process
            this.step1_loadCoreConfiguration();
            this.step2_templateCompletenessValidation();
            this.step3_fileStructureValidation();
            this.step4_uiFrontendValidation();
            this.step5_acceptanceCriteriaAssessment();
            this.step6_validationTestingInstructions();
            this.step7_securityConsiderations();
            this.step8_tasksSubtasksSequence();
            this.step9_antiHallucinationVerification();
            this.step10_generateReport();
            
            return this.generateOutput();
        } catch (error) {
            return this.generateErrorOutput(error);
        }
    }

    async loadStoryFile() {
        // Security: Validate file path
        if (!this.filePath || typeof this.filePath !== 'string') {
            throw new Error('Invalid file path provided');
        }
        
        // Security: Prevent path traversal (allow stories and test directories)
        const resolvedPath = path.resolve(this.filePath);
        const allowedPaths = ['/stories/', '/test', 'stories/', 'test/'];
        const isAllowed = allowedPaths.some(allowedPath => resolvedPath.includes(allowedPath));
        
        if (!isAllowed) {
            throw new Error(`File path not in allowed directory: ${resolvedPath}`);
        }
        
        if (!fs.existsSync(this.filePath)) {
            throw new Error(`Story file not found: ${this.filePath}`);
        }
        
        // Security: Check file size (prevent DoS via large files)
        const stats = fs.statSync(this.filePath);
        if (stats.size > 10 * 1024 * 1024) { // 10MB limit
            throw new Error('Story file too large (max 10MB)');
        }
        
        this.content = fs.readFileSync(this.filePath, 'utf8');
        
        if (!this.content.trim()) {
            throw new Error('Story file is empty');
        }
        
        // Detect if content was generated by a sub-agent
        this.detectSubAgentGeneration();
        
        // Security: Validate content encoding (allow for multi-byte UTF-8 characters)
        try {
            const buffer = Buffer.from(this.content, 'utf8');
            const reconstructed = buffer.toString('utf8');
            if (reconstructed !== this.content) {
                throw new Error('Invalid file encoding - must be UTF-8');
            }
        } catch (error) {
            throw new Error('Invalid file encoding - must be UTF-8');
        }
    }

    detectSubAgentGeneration() {
        // Check for sub-agent indicators in content
        const subAgentPatterns = [
            /Agent Model Used.*Claude/i,
            /ðŸ¤– Generated with \[Claude Code\]/i,
            /Sub-agent:/i,
            /Co-Authored-By: Claude/i,
            /Generated by.*agent/i
        ];
        
        for (const pattern of subAgentPatterns) {
            const match = this.content.match(pattern);
            if (match) {
                this.isSubAgent = true;
                this.subAgentInfo = {
                    detected: true,
                    indicator: match[0],
                    pattern: pattern.toString()
                };
                break;
            }
        }
        
        // Extract specific agent information if available
        if (this.isSubAgent) {
            const agentModelMatch = this.content.match(/Agent Model Used:\s*(.+)/i);
            const agentNameMatch = this.content.match(/Agent:\s*(.+)/i);
            
            if (agentModelMatch || agentNameMatch) {
                this.subAgentInfo.model = agentModelMatch ? agentModelMatch[1].trim() : null;
                this.subAgentInfo.name = agentNameMatch ? agentNameMatch[1].trim() : null;
            }
        }
    }

    step1_loadCoreConfiguration() {
        // Check if story follows user story format - more flexible regex
        const userStoryPattern = /\*\*As a\*\*.*\*\*I want\*\*.*\*\*so that\*\*/is;
        if (!userStoryPattern.test(this.content)) {
            this.issues.critical.push('Story does not follow required user story format (As a... I want... so that...)');
        }
    }

    step2_templateCompletenessValidation() {
        const missingSections = [];
        
        REQUIRED_SECTIONS.forEach(section => {
            const sectionPattern = new RegExp(`^##\\s+${section}`, 'm');
            if (!sectionPattern.test(this.content)) {
                missingSections.push(section);
            }
        });
        
        if (missingSections.length > 0) {
            this.issues.critical.push(`Missing required sections: ${missingSections.join(', ')}`);
        } else {
            this.score += CONFIG.COMPLETENESS_BONUS;
        }
        
        // Check for unfilled template variables
        const templateVars = this.content.match(/\{\{[^}]+\}\}/g);
        if (templateVars && templateVars.length > 0) {
            this.issues.shouldFix.push(`Unfilled template variables found: ${templateVars.join(', ')}`);
        }
    }

    step3_fileStructureValidation() {
        // Check if story references valid file paths
        const fileReferences = this.content.match(/[\/\w\-\.]+\.(js|ts|md|json|yaml|sh)/g);
        if (fileReferences) {
            // Filter out relative paths and focus on absolute paths that should exist
            const criticalFiles = fileReferences.filter(filePath => 
                filePath.startsWith('/') && 
                !filePath.startsWith('/Users/') &&
                !filePath.includes('example') &&
                !filePath.includes('template')
            );
            
            const invalidFiles = criticalFiles.filter(filePath => {
                try {
                    const fullPath = path.resolve(filePath);
                    return !fs.existsSync(fullPath);
                } catch (error) {
                    return true; // Invalid path format
                }
            });
            
            if (invalidFiles.length > 0) {
                this.issues.shouldFix.push(`Referenced critical files not found: ${invalidFiles.join(', ')}`);
            }
        }
    }

    step4_uiFrontendValidation() {
        // Check for UI/frontend considerations if applicable
        const uiKeywords = ['interface', 'component', 'frontend', 'UI', 'user interface'];
        const hasUIContent = uiKeywords.some(keyword => 
            this.content.toLowerCase().includes(keyword.toLowerCase())
        );
        
        if (hasUIContent) {
            const hasUISpec = /user interface|UI design|component spec/i.test(this.content);
            if (!hasUISpec) {
                this.issues.niceToHave.push('Story mentions UI elements but lacks detailed interface specifications');
            }
        }
    }

    step5_acceptanceCriteriaAssessment() {
        const acSection = this.extractSection('Acceptance Criteria');
        if (!acSection) {
            this.issues.critical.push('Acceptance Criteria section is missing or empty');
            return;
        }
        
        // Check for testable criteria
        const criteria = acSection.split('\n').filter(line => line.trim().match(/^\d+\./));
        if (criteria.length === 0) {
            this.issues.critical.push('No numbered acceptance criteria found');
        }
        
        // Check for vague criteria
        const vaguePatterns = ['implement', 'create', 'build', 'make'];
        const vagueCriteria = criteria.filter(criterion => 
            vaguePatterns.some(pattern => criterion.toLowerCase().includes(pattern))
        );
        
        if (vagueCriteria.length > 0) {
            this.issues.shouldFix.push('Some acceptance criteria are vague and may not be testable');
        }
    }

    step6_validationTestingInstructions() {
        const hasTestingSection = /testing|test|validation/i.test(this.content);
        if (!hasTestingSection) {
            this.issues.shouldFix.push('Missing testing strategy or validation instructions');
        }
    }

    step7_securityConsiderations() {
        const securityKeywords = ['security', 'authentication', 'authorization', 'validation', 'sanitization'];
        const hasSecurityContent = securityKeywords.some(keyword => 
            this.content.toLowerCase().includes(keyword.toLowerCase())
        );
        
        if (hasSecurityContent) {
            const hasSecuritySpec = /security consideration|auth|validation|sanitization/i.test(this.content);
            if (!hasSecuritySpec) {
                this.issues.shouldFix.push('Story mentions security elements but lacks detailed security specifications');
            }
        }
    }

    step8_tasksSubtasksSequence() {
        const tasksSection = this.extractSection('Tasks / Subtasks');
        if (!tasksSection) {
            this.issues.critical.push('Tasks/Subtasks section is missing');
            return;
        }
        
        // Check for task structure
        const tasks = tasksSection.match(/- \[ \]/g);
        if (!tasks || tasks.length === 0) {
            this.issues.shouldFix.push('No checkboxed tasks found in Tasks/Subtasks section');
        }
        
        // Check for circular dependencies
        const taskLines = tasksSection.split('\n').filter(line => line.includes('[ ]'));
        const hasDependencies = taskLines.some(line => line.includes('depends on') || line.includes('requires'));
        if (hasDependencies) {
            this.issues.niceToHave.push('Consider reviewing task dependencies for potential circular references');
        }
    }

    step9_antiHallucinationVerification() {
        let hallucinationIssues = 0;
        const verificationResults = [];
        
        // Sub-agent content gets different validation rules 
        const claimPatterns = this.isSubAgent ? [
            // More lenient patterns for sub-agent generated content
            {pattern: /\d+%\s+(improvement|increase|reduction)/i, severity: 'high'},
            {pattern: /\b(proven|demonstrated|verified)\b/i, severity: 'moderate'}
        ] : [
            // Standard patterns for human-generated content
            {pattern: /\b(complete|completed|operational|working|tested)\b/i, severity: 'moderate'},
            {pattern: /\d+%\s+(improvement|increase|reduction)/i, severity: 'high'},
            {pattern: /\b(proven|demonstrated|verified)\b/i, severity: 'high'}
        ];
        
        claimPatterns.forEach(({pattern, severity}) => {
            const matches = this.content.match(new RegExp(pattern, 'gi'));
            if (matches && matches.length > 0) {
                // Only flag if not in proper context (like "to be completed" or "needs to be tested")
                const contextuallyValid = matches.some(match => {
                    const context = this.getMatchContext(match, 50);
                    return context.includes('to be') || context.includes('will be') || 
                           context.includes('should be') || context.includes('needs');
                });
                
                if (!contextuallyValid) {
                    hallucinationIssues++;
                    verificationResults.push(`${severity} claim: "${matches[0]}" may be unverifiable`);
                }
            }
        });
        
        // Check for contradictory status
        const statusSection = this.extractSection('Status');
        const storySection = this.extractSection('Story');
        
        if (statusSection && storySection) {
            if (statusSection.includes('Complete') && storySection.includes('want to implement')) {
                this.issues.critical.push('Status shows Complete but Story indicates implementation needed');
            }
        }
        
        if (hallucinationIssues === 0) {
            this.score += CONFIG.ANTI_HALLUCINATION_BONUS;
        } else if (hallucinationIssues <= 2) {
            this.issues.niceToHave.push(`Found ${hallucinationIssues} potentially unverifiable claims - consider adding evidence or qualifying language`);
        } else {
            this.issues.shouldFix.push(`Found ${hallucinationIssues} potentially unverifiable claims requiring verification`);
        }
        
        // Add bonus for confirmed sub-agent content with proper attribution
        if (this.isSubAgent && this.subAgentInfo) {
            this.score += 0.5; // Bonus for proper sub-agent attribution
        }
    }

    getMatchContext(match, contextLength = 50) {
        const matchIndex = this.content.indexOf(match);
        const start = Math.max(0, matchIndex - contextLength);
        const end = Math.min(this.content.length, matchIndex + match.length + contextLength);
        return this.content.slice(start, end).toLowerCase();
    }

    step10_generateReport() {
        // Calculate final score
        this.score -= this.issues.critical.length * CONFIG.CRITICAL_PENALTY;
        this.score -= this.issues.shouldFix.length * CONFIG.SHOULD_FIX_PENALTY;
        this.score -= this.issues.niceToHave.length * CONFIG.NICE_TO_HAVE_PENALTY;
        
        // Ensure score is within bounds
        this.score = Math.max(0, Math.min(10, this.score));
    }

    extractSection(sectionName) {
        // Performance: Use cached result if available
        if (this.sectionCache.has(sectionName)) {
            return this.sectionCache.get(sectionName);
        }
        
        const sectionPattern = new RegExp(`^##\\s+${sectionName}\\s*$`, 'm');
        const match = this.content.match(sectionPattern);
        
        if (!match) {
            this.sectionCache.set(sectionName, null);
            return null;
        }
        
        const sectionStart = match.index + match[0].length;
        const nextSectionPattern = /^##\s+/m;
        const remainingContent = this.content.slice(sectionStart);
        const nextSectionMatch = remainingContent.match(nextSectionPattern);
        
        const sectionEnd = nextSectionMatch ? sectionStart + nextSectionMatch.index : this.content.length;
        const result = this.content.slice(sectionStart, sectionEnd).trim();
        
        // Performance: Cache the result
        this.sectionCache.set(sectionName, result);
        return result;
    }

    generateOutput() {
        const status = this.score >= 7 ? 'PASS' : 'FAIL';
        const recommendation = this.getRecommendation();
        
        const output = {
            score: this.score.toFixed(1),
            status: status,
            recommendation: recommendation,
            issues: this.issues,
            summary: `Story validation ${status.toLowerCase()} with score ${this.score.toFixed(1)}/10`
        };
        
        // Add sub-agent information if detected
        if (this.isSubAgent && this.subAgentInfo) {
            output.subAgent = this.subAgentInfo;
            output.summary += ` (Sub-agent generated content)`;
        }
        
        return output;
    }

    generateErrorOutput(error) {
        return {
            score: '0.0',
            status: 'ERROR',
            recommendation: 'Fix validation errors and try again',
            error: error.message,
            summary: `Validation failed: ${error.message}`
        };
    }

    getRecommendation() {
        if (this.score >= 9) return 'Ready for immediate implementation';
        if (this.score >= 7) return 'Minor issues, can proceed with caution';
        if (this.score >= 5) return 'Moderate issues, fixes recommended before implementation';
        if (this.score >= 3) return 'Major issues, fixes required before proceeding';
        return 'Severe issues, complete story revision needed';
    }
}

// Main execution
async function main() {
    const filePath = process.argv[2];
    const isSubAgent = process.argv.includes('--sub-agent');
    
    if (!filePath) {
        console.error('Usage: story-validation-engine.js <story_file_path> [--sub-agent]');
        process.exit(1);
    }
    
    const engine = new StoryValidationEngine(filePath, isSubAgent);
    const result = await engine.validate();
    
    // Output for hook consumption
    console.log(`SCORE: ${result.score}`);
    console.log(`STATUS: ${result.status}`);
    console.log(`RECOMMENDATION: ${result.recommendation}`);
    
    if (result.issues) {
        if (result.issues.critical.length > 0) {
            console.log(`CRITICAL: ${result.issues.critical.join('; ')}`);
        }
        if (result.issues.shouldFix.length > 0) {
            console.log(`SHOULD_FIX: ${result.issues.shouldFix.join('; ')}`);
        }
        if (result.issues.niceToHave.length > 0) {
            console.log(`NICE_TO_HAVE: ${result.issues.niceToHave.join('; ')}`);
        }
    }
    
    process.exit(result.status === 'PASS' ? 0 : 1);
}

// Check if this is the main module (ES module equivalent of require.main === module)
if (import.meta.url === `file://${process.argv[1]}`) {
    main().catch(error => {
        console.error('VALIDATION_ERROR:', error.message);
        process.exit(1);
    });
}

export default StoryValidationEngine;